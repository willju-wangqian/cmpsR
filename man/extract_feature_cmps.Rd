% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cmps.R
\name{extract_feature_cmps}
\alias{extract_feature_cmps}
\title{Computes the CMPS score of a comparison between two bullet profiles/signatures}
\usage{
extract_feature_cmps(
  x,
  y,
  seg_length = 50,
  seg_scale_max = 3,
  Tx = 25,
  npeaks.set = c(5, 3, 1),
  full_result = FALSE
)
}
\arguments{
\item{x}{a numeric vector, vector of the reference bullet signature/profile that will be divided into basis segments}

\item{y}{a numeric vector, vector of the comparison bullet signature/profile}

\item{seg_length}{integer, integer, the length of a basis segment}

\item{seg_scale_max}{integer, the maximum scale of the segment.
\itemize{
\item If setting \code{seg_scale_max = 1}, the algorithm uses multi-peak inspection only at the basis scale;
\item If setting \code{seg_scale_max} to be an integer greater than 1, the algorithm uses multi-peak inspection at
different segment scales.
\item By default, \code{seg_scale_max = 3}. Increasing \code{seg_scale_max} will reduce the number of false positive results
}}

\item{Tx}{integer, the tolerance zone is \verb{+/- Tx}}

\item{npeaks.set}{a numeric vector, specify the number of peaks to be found for each different scale of segment. The
number of peaks for the highest segment scale must be 1, i.e., the very last element of \code{npeaks.set} must be 1.}

\item{full_result}{boolean, whether or not to return the full CMPS result}
}
\value{
integer or a list
\itemize{
\item if \code{full_result = FALSE}, return the CMPS number only
\item if \code{full_result = TRUE}, return a list of four elements:
\itemize{
\item \code{CMPS.score}: computed CMPS score
\item \code{rec.position}: the recommended position that results in the CMPS score
\item \code{pos.df}: a dataframe that includes all positions and their corresponding CMPS score
\item \code{nseg}: the number of basis segments obtained from the reference profile
}
}
}
\description{
Compute the Congruent Matching Profile Segments (CMPS) score based on two bullet profiles/signatures.
The reference profile will be divided into consecutive, non-overlapping, basis segments of the same length.
Then the number of segments that are congruent matching will be found as the CMPS score.
By default, \code{extract_feature_cmps} implements the algorithm with multi-peak insepction at three
different segment scales. By setting \code{seg_scale_max = 1}, users can switch to the algorithm
with multi-peak inspection at the basis scale only.
}
\examples{
library(bulletxtrctr)
library(tidyverse)
library(x3ptools)
library(CMPS)

data("bullets")
land2_3 <- bullets$sigs[bullets$bulletland == "2-3"][[1]]
land1_2 <- bullets$sigs[bullets$bulletland == "1-2"][[1]]

# compute cmps

# algorithm with multi-peak insepction at three different segment scales
cmps_with_multi_scale <- extract_feature_cmps(land2_3$sig, land1_2$sig, full_result = TRUE)

# algorithm with multi-peak inspection at the basis scale only
cmps_without_multi_scale <- extract_feature_cmps(land2_3$sig, land1_2$sig, seg_scale_max = 1, 
                                                 npeaks.set = 5, full_result = TRUE)
\dontrun{
library(tidyverse)
library(bulletxtrctr)

lands <- unique(bullets$bulletland)

comparisons <- data.frame(expand.grid(land1 = lands[1:6], land2 = lands[7:12]), 
                          stringsAsFactors = FALSE)

comparisons <- comparisons \%>\% mutate(
  aligned = purrr::map2(.x = land1, .y = land2, 
                        .f = function(xx, yy) {
                          land1 <- bullets$sigs[bullets$bulletland == xx][[1]]
                          land2 <- bullets$sigs[bullets$bulletland == yy][[1]]
                          land1$bullet <- "first-land"
                          land2$bullet <- "second-land"
                          
                          sig_align(land1$sig, land2$sig)
                        }))

comparisons <- comparisons \%>\% 
  mutate(cmps = aligned \%>\% purrr::map(.f = function(a) {
    extract_feature_cmps(a$lands$sig1, a$lands$sig2, full_result = TRUE)
  }))

# comparisons.cmps <- comparisons.cmps \%>\% 
#   mutate(cmps = aligned \%>\% purrr::map_dbl(.f = function(a) {
#     extract_feature_cmps(a$lands$sig1, a$lands$sig2, full_result = FALSE)
#   }))
# comparisons.cmps \%>\% select(land1, land2, cmps) 

comparisons <- comparisons \%>\% 
  mutate(
    cmps_score = sapply(comparisons$cmps, function(x) x$CMPS.score),
    cmps_nseg = sapply(comparisons$cmps, function(x) x$nseg)
  )

cp1 <- comparisons \%>\% select(land1, land2, cmps_score, cmps_nseg)
cp1
}
}
